/**
 * @file    factor_set.cc
 * The implementation of a class used to represent a factor set.
 */

#include <assert.h>

#include "h2sl/common.h"
#include "h2sl/constraint.h"
#include "h2sl/world.h"
#include "h2sl/grounding.h"
#include "h2sl/object.h"
#include "h2sl/object_property.h"
#include "h2sl/index.h"
#include "h2sl/number.h"
#include "h2sl/phrase.h"
#include "h2sl/abstract_container.h"
#include "h2sl/region_abstract_container.h"
#include "h2sl/container.h"
#include "h2sl/region_container.h"
#include "h2sl/spatial_relation.h"

#include "h2sl/factor_set_adcg.h"

using namespace std;
using namespace h2sl;

bool
factor_set_adcg_solution_sort( const Factor_Set_Solution& a,
                              const Factor_Set_Solution& b ){
  return a.pygx() > b.pygx();
}

Factor_Set_ADCG::
Factor_Set_ADCG( const Phrase* phrase ) : Factor_Set( phrase ),
                                              _abstract_search_spaces() {
}

Factor_Set_ADCG::
~Factor_Set_ADCG() {

}

Factor_Set_ADCG::
Factor_Set_ADCG( const Factor_Set_ADCG& other ) : Factor_Set( other ),
                                             _abstract_search_spaces( other._abstract_search_spaces ) {

}


Factor_Set_ADCG&
Factor_Set_ADCG::
operator=( const Factor_Set_ADCG& other ) {
  _phrase = other._phrase;
  _child_factor_sets = other._child_factor_sets;
  _solutions = other._solutions;
  _abstract_search_spaces = other._abstract_search_spaces;
  return (*this);
}

void
Factor_Set_ADCG::
search( const Search_Space* searchSpace, 
        const Symbol_Dictionary& symbolDictionary,
        const World* world,
        LLM* llm,
        const unsigned int beamWidth,
        const bool& debug ){
  search( searchSpace, symbolDictionary, world, NULL, llm, beamWidth, debug );
  return;
}

void
Factor_Set_ADCG::
search( const Search_Space* searchSpace, 
        const Symbol_Dictionary& symbolDictionary,
        const World* world,
        const Grounding* context,
        LLM* llm,
        const unsigned int beamWidth,
        const bool& debug ){
  if( debug ){
    cout << "phrase:" << *_phrase << endl;
  }
  //_search_physical( searchSpace, symbolDictionary, world, llm, beamWidth, debug );

  /**************** CREATE CHILD SOLUTION COMBOS ***********************/

  // Create the vector that will have the child solutions indices.      
  vector< vector< unsigned int > > child_solution_indices;
  for( unsigned int i = 0; i < _child_factor_sets.size(); i++ ){
    child_solution_indices.push_back( vector< unsigned int >() );
    for( unsigned int j = 0; j < _child_factor_sets[ i ]->solutions().size(); j++ ){
      child_solution_indices.back().push_back( j );
    }
  }

  // Create the indices for the child solution combos (power set).
  vector< vector< unsigned int > > child_solution_indices_cartesian_power = cartesian_power( child_solution_indices );
  if( child_solution_indices_cartesian_power.empty() ){
    child_solution_indices_cartesian_power.push_back( vector< unsigned int >() );
  }

  vector< bool > evaluate_feature_types( NUM_FEATURE_TYPES, true );

  if( debug ){
    cout << "concrete search space" << endl;
    for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_search_spaces = searchSpace->grounding_pairs().begin(); it_search_spaces != searchSpace->grounding_pairs().end(); it_search_spaces++ ){
      cout << "searching through symbols for \"" << it_search_spaces->first << "\" (" << it_search_spaces->second.second.size() << " symbols)" << endl;
    }
  }

  insert_prop< std::string >( _properties, "concrete_size", to_std_string( searchSpace->size() ) );
  /**************** MARCH THROUGH THE CHILD SOLUTION COMBOS***********************/

 vector< vector< Factor_Set_Solution > > solutions_vector;
  // add a Factor_Set_Solution for each combination of children
  for( unsigned int i = 0; i < child_solution_indices_cartesian_power.size(); i++ ){
    solutions_vector.push_back( vector< Factor_Set_Solution >() );

    // start with an empty solution vector, set the childen equal to the children generated by the cartesian power
    solutions_vector.back().push_back( Factor_Set_Solution() );
    solutions_vector.back().back().child_solution_indices() = child_solution_indices_cartesian_power[ i ];

    // generate the child groundings for the cartesian power
    vector< pair< const Phrase*, vector< Grounding* > > > child_groundings;
    for( unsigned int j = 0; j < child_solution_indices_cartesian_power[ i ].size(); j++ ){
      solutions_vector.back().back().pygx() *= _child_factor_sets[ j ]->solutions()[ child_solution_indices_cartesian_power[ i ][ j ] ].pygx();
      child_groundings.push_back( pair< const Phrase*, vector< Grounding* > >( _child_factor_sets[ j ]->phrase(), _child_factor_sets[ j ]->solutions()[ child_solution_indices_cartesian_power[ i ][ j ] ].grounding_set()->groundings() ) );
    }

    // search over all of the class-based search spaces
    for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_search_spaces = searchSpace->grounding_pairs().begin(); it_search_spaces != searchSpace->grounding_pairs().end(); it_search_spaces++ ){
      map< string, vector< string > >::const_iterator it_cvs = searchSpace->cvs().find( it_search_spaces->second.first );
      assert( it_cvs != searchSpace->cvs().end() );

      // search the subspace that incrementally populates the solution vectors
      search_subspace( solutions_vector.back(),
                        child_groundings,
                        it_search_spaces->second,
                        it_cvs->second,
                        evaluate_feature_types,
                        context, world, llm, beamWidth, debug );

    }

    if( debug ){
      for( unsigned int i = 0; i < solutions_vector.back().size(); i++ ){
        cout << "solutions_vector.back()[" << i << "] (pygx:" << solutions_vector.back()[ i ].pygx() << ")" << endl;
        cout << "  grounding_set" << *solutions_vector.back()[ i ].grounding_set() << endl;
        cout << "  child_solution_indices[" << solutions_vector.back()[ i ].child_solution_indices().size() << "]:{";
        for( unsigned int j = 0; j < solutions_vector.back()[ i ].child_solution_indices().size(); j++ ){
          cout << "(\"" << _child_factor_sets[ j ]->phrase()->words_to_std_string() << "\":" << solutions_vector.back()[ i ].child_solution_indices()[ j ] << ")";
          if( j != ( solutions_vector.back()[ i ].child_solution_indices().size() - 1 ) ){
            cout << ",";
          }
        }
        cout << "}" << endl;
      }
    }

    // distribution of inferrred concrete and abstract symbols
    vector< vector< Factor_Set_Solution > > combined_solutions_vector;

    // Symbol dictionaries for the current inference with the child solution combo.
    vector< pair< double, Symbol_Dictionary > > inferred_concrete_symbol_dictionaries;
    // Iterate and scrape the groundings from the solutions found. Record the probabilities.
    for( vector< Factor_Set_Solution >::const_iterator it_solution = solutions_vector.back().begin(); it_solution !=  solutions_vector.back().end(); it_solution++) {
      inferred_concrete_symbol_dictionaries.push_back( pair< double, Symbol_Dictionary >( it_solution->pygx(), Symbol_Dictionary( symbolDictionary, "abstract" ) ) );
      it_solution->grounding_set()->scrape_grounding( world, 
                                                     inferred_concrete_symbol_dictionaries.back().second.string_types(), 
                                                     inferred_concrete_symbol_dictionaries.back().second.int_types() );
      for( unsigned int j = 0; j < child_groundings.size(); j++ ){
        for( unsigned int k = 0; k < child_groundings[ j ].second.size(); k++ ){
          child_groundings[ j ].second[ k ]->scrape_grounding( world, 
                                                    inferred_concrete_symbol_dictionaries.back().second.string_types(),
                                                    inferred_concrete_symbol_dictionaries.back().second.int_types() );
        }
      }
      inferred_concrete_symbol_dictionaries.back().second.class_names() = symbolDictionary.class_names();

      combined_solutions_vector.push_back( vector< Factor_Set_Solution >() );
      combined_solutions_vector.back().push_back( *it_solution );
      
      // Print out for debug.
      if( debug ){
        cout << "inferred concrete symbol dictionary (" << inferred_concrete_symbol_dictionaries.back().first << "):(" << inferred_concrete_symbol_dictionaries.back().second << ")" << endl;
      }
   
      // Creating the ssearch space from the symbol dictionary with abstract flag on.
      _abstract_search_spaces.push_back( new Search_Space() );
      _abstract_search_spaces.back()->fill_groundings( inferred_concrete_symbol_dictionaries.back().second, world, "abstract" );

      // Print out the abstract search space.
      if( debug ){
        cout << "abstract search space" << endl;
        for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_search_spaces = _abstract_search_spaces.back()->grounding_pairs().begin(); it_search_spaces != _abstract_search_spaces.back()->grounding_pairs().end(); it_search_spaces++ ){
          cout << "searching through symbols for \"" << it_search_spaces->first << "\" (" << it_search_spaces->second.second.size() << " symbols)" << endl;
        }
      }

      // search over the class-based search spaces for the abstract symbols.
      for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_abstract_search_spaces = _abstract_search_spaces.back()->grounding_pairs().begin(); it_abstract_search_spaces != _abstract_search_spaces.back()->grounding_pairs().end(); it_abstract_search_spaces++ ){
        map< string, vector< string > >::const_iterator it_abstract_cvs = _abstract_search_spaces.back()->cvs().find( it_abstract_search_spaces->second.first );
        assert( it_abstract_cvs != _abstract_search_spaces.back()->cvs().end() );

        // search the subspace that incrementally populates the solution vectors
        search_subspace( combined_solutions_vector.back(),
                        child_groundings,
                        it_abstract_search_spaces->second,
                        it_abstract_cvs->second,
                        evaluate_feature_types,
                        context, world, llm, beamWidth, debug );

      }

      if( debug ){
        for( unsigned int i = 0; i < combined_solutions_vector.back().size(); i++ ){
          cout << "combined_solutions_vector.back()[" << i << "] (pygx:" << combined_solutions_vector.back()[ i ].pygx() << ")" << endl;
          cout << "  grounding_set" << *combined_solutions_vector.back()[ i ].grounding_set() << endl;
          cout << "  child_solution_indices[" << combined_solutions_vector.back()[ i ].child_solution_indices().size() << "]:{";
          for( unsigned int j = 0; j < combined_solutions_vector.back()[ i ].child_solution_indices().size(); j++ ){
            cout << "(\"" << _child_factor_sets[ j ]->phrase()->words_to_std_string() << "\":" << combined_solutions_vector.back()[ i ].child_solution_indices()[ j ] << ")";
            if( j != ( combined_solutions_vector.back()[ i ].child_solution_indices().size() - 1 ) ){
              cout << ",";
            } 
          }
          cout << "}" << endl;
        }
      }

    }

    /**************** FLATTEN THE TMP SOLUTIONS ***********************/
    solutions_vector.back().clear();
    for( unsigned int i = 0; i < combined_solutions_vector.size(); i++ ){
      for( unsigned int j = 0; j < combined_solutions_vector[ i ].size(); j++ ){
        solutions_vector.back().push_back( combined_solutions_vector[ i ][ j ] );
      }
    }

    sort( solutions_vector.back().begin(), solutions_vector.back().end(), factor_set_adcg_solution_sort );
    if( solutions_vector.back().size() > beamWidth ){
      solutions_vector.back().erase( solutions_vector.back().begin() + beamWidth, solutions_vector.back().end() );
    }
  }

  /**************** FLATTEN THE SOLUTIONS ***********************/
  _solutions.clear();
  for( unsigned int i = 0; i < solutions_vector.size(); i++ ){
    for( unsigned int j = 0; j < solutions_vector[ i ].size(); j++ ){
      _solutions.push_back( solutions_vector[ i ][ j ] );
    }
  }

  /**************** SORT AND TRIM SOLUTIONS ***********************/
  if( debug ){
    cout << "  sorting through " << _solutions.size() << " solutions for \"" << _phrase->words_to_std_string() << "\"" << endl;
  }

  sort( _solutions.begin(), _solutions.end(), factor_set_adcg_solution_sort );
  if( _solutions.size() > beamWidth ){
    _solutions.erase( _solutions.begin() + beamWidth, _solutions.end() );
  }

  /**************** RECORD THE MAX. ABSTRACT SEARCH SPACE SIZE ***********************/
  unsigned int max_size = 0.0;
  for( unsigned int i = 0; i < _abstract_search_spaces.size(); i++ ){
    if( i == 0 ){
      max_size = _abstract_search_spaces[ i ]->size();
    } else if ( _abstract_search_spaces[ i ]->size() > max_size ){
      max_size = _abstract_search_spaces[ i ]->size();
    }
  }

  double avg_size = 0.0;
  if( !_abstract_search_spaces.empty() ) {
    for( unsigned int i = 0; i < _abstract_search_spaces.size(); i++ ){
      avg_size += _abstract_search_spaces[ i ]->size();
    }
    avg_size /= ( double )( _abstract_search_spaces.size() );
  }

  insert_prop< std::string >( _properties, "abstract_max_size", to_std_string( max_size ) );
  insert_prop< std::string >( _properties, "abstract_avg_size", to_std_string( avg_size ) );
  /**************** PRINT OUT THE SOLUTIONS IF REQD.***********************/

  if( debug ){
    for( unsigned int i = 0; i < _solutions.size(); i++ ){
      cout << "solution[" << i << "] (pygx:" << _solutions[ i ].pygx() << ")" << endl;
      cout << "  grounding_set" << *_solutions[ i ].grounding_set() << endl;
      cout << "  child_solution_indices[" << _solutions[ i ].child_solution_indices().size() << "]:{";
      for( unsigned int j = 0; j < _solutions[ i ].child_solution_indices().size(); j++ ){
        cout << "(\"" << _child_factor_sets[ j ]->phrase()->words_to_std_string() << "\":" << _solutions[ i ].child_solution_indices()[ j ] << ")";
        if( j != ( _solutions[ i ].child_solution_indices().size() - 1 ) ){
          cout << ",";
        }
      }
      cout << "}" << endl;
      cout << "  child grounding_sets[" << _solutions[ i ].child_solution_indices().size() << "]:{";
      for( unsigned int j = 0; j < _solutions[ i ].child_solution_indices().size(); j++ ){
        cout <<  "(\"" << _child_factor_sets[ j ]->phrase()->words_to_std_string() << "\":(groundings" << *_child_factor_sets[ j ]->solutions()[ _solutions[ i ].child_solution_indices()[ j ] ].grounding_set() << "))";
        if( j != ( _solutions[ i ].child_solution_indices().size() - 1 ) ){
          cout << ",";
        }
      }
      cout << "}" << endl;
    }
    cout << endl;
  }

  return;
}


namespace h2sl {
  ostream&
  operator<<( ostream& out,
              const Factor_Set_ADCG& other ){
    return out;
  }
}






































